---
interface Props {
  sceneType?: 'cube' | 'sphere' | 'torus' | 'cylinder' | 'cone' | 'octahedron' | 'tetrahedron' | 'dodecahedron' | 'icosahedron' | 'water' | 'methane' | 'ammonia' | 'co2' | 'benzene' | 'ethanol';
  height?: string;
}

const { sceneType = 'cube', height = '500px' } = Astro.props;
const sceneId = `scene-${Math.random().toString(36).substr(2, 9)}`;
---

<div id={sceneId} class="three-wrapper">
  <button class="bg-toggle-btn" title="Toggle Background">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
      <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
    </svg>
  </button>
  <div class="fps-counter">FPS: <span class="fps-value">--</span></div>
  <div class="three-container" style={`height: ${height}`} data-scene-type={sceneType}></div>
</div>

<script>
  import * as THREE from 'three';

  // Check WebGL support
  function isWebGLAvailable() {
    try {
      const canvas = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && 
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
      return false;
    }
  }

  // Find all three wrappers and initialize them
  document.querySelectorAll('.three-wrapper').forEach((wrapperEl: Element) => {
    const wrapper = wrapperEl as HTMLElement;
    const container = wrapper.querySelector('.three-container') as HTMLElement;
    const sceneType = container.dataset.sceneType || 'cube';
    
    // Skip if already initialized
    if (container.querySelector('canvas')) return;
    
    // Check WebGL support
    if (!isWebGLAvailable()) {
      const errorMsg = document.createElement('div');
      errorMsg.textContent = 'WebGL is not supported in your browser. Please use a modern browser to view 3D scenes.';
      errorMsg.style.color = '#e74c3c';
      errorMsg.style.padding = '2rem';
      errorMsg.style.textAlign = 'center';
      container.appendChild(errorMsg);
      return;
    }
    
    // Scene setup
    const scene = new THREE.Scene();
    
    // Background toggle state (0: light, 1: dark)
    let bgMode = 0;
    const bgColors = [0xf0f0f0, 0x1a1a2e]; // light, dark
    scene.background = new THREE.Color(bgColors[0]);
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 5;
    
    // Renderer - mobile optimized
    const renderer = new THREE.WebGLRenderer({ 
      antialias: window.devicePixelRatio <= 1, // Disable antialiasing on high DPI for performance
      powerPreference: 'high-performance',
      alpha: false, // Opaque background for better performance
      stencil: false, // Disable stencil buffer for performance
      depth: true,
      preserveDrawingBuffer: true // Prevents canvas from being cleared unexpectedly
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    
    // Force immediate render to ensure canvas is visible
    renderer.render(scene, camera);
    
    container.appendChild(renderer.domElement);
    
    // Force another render after appending to DOM
    requestAnimationFrame(() => {
      renderer.render(scene, camera);
    });
    
    // Removed THREE.Clock - using manual delta time calculation for better performance
    
    // Enhanced Lighting for better visibility
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    
    // Main light from top-right
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(5, 5, 5);
    scene.add(mainLight);
    
    // Fill light from left
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
    fillLight.position.set(-5, 3, 2);
    scene.add(fillLight);
    
    // Back light for depth
    const backLight = new THREE.DirectionalLight(0xffffff, 0.4);
    backLight.position.set(0, 2, -5);
    scene.add(backLight);
    
    // Molecular structure helper functions
    const moleculeTypes = ['water', 'methane', 'ammonia', 'co2', 'benzene', 'ethanol'];
    const isMolecule = moleculeTypes.includes(sceneType);
    
    function createAtom(color: number, size: number) {
      const geometry = new THREE.SphereGeometry(size, 32, 32);
      const material = new THREE.MeshPhongMaterial({ 
        color, 
        shininess: 100,
        specular: 0x555555
      });
      const mesh = new THREE.Mesh(geometry, material);
      // Disable frustum culling to prevent disappearing
      mesh.frustumCulled = false;
      return mesh;
    }
    
    function createBond(start: THREE.Vector3, end: THREE.Vector3, color: number = 0xcccccc) {
      const direction = new THREE.Vector3().subVectors(end, start);
      const length = direction.length();
      const geometry = new THREE.CylinderGeometry(0.08, 0.08, length, 8);
      const material = new THREE.MeshPhongMaterial({ color });
      const bond = new THREE.Mesh(geometry, material);
      // Disable frustum culling to prevent disappearing
      bond.frustumCulled = false;
      
      bond.position.copy(start).add(direction.multiplyScalar(0.5));
      bond.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        direction.normalize()
      );
      
      return bond;
    }
    
    let mesh: THREE.Object3D;
    let geometry: THREE.BufferGeometry | undefined;
    let edges: THREE.EdgesGeometry | undefined;
    let lineMaterial: THREE.LineBasicMaterial | undefined;
    let wireframe: THREE.LineSegments | undefined;
    
    if (isMolecule) {
      // Create molecular structure
      const molecule = new THREE.Group();
      // Disable frustum culling for the entire group
      molecule.frustumCulled = false;
      
      // Atom colors (CPK coloring convention)
      const colors = {
        H: 0xffffff,  // Hydrogen - white
        C: 0x909090,  // Carbon - gray
        O: 0xff0000,  // Oxygen - red
        N: 0x3050f8,  // Nitrogen - blue
      };
      
      switch (sceneType) {
        case 'water': // H2O
          const O = createAtom(colors.O, 0.4);
          const H1 = createAtom(colors.H, 0.25);
          const H2 = createAtom(colors.H, 0.25);
          
          H1.position.set(-0.6, 0.4, 0);
          H2.position.set(0.6, 0.4, 0);
          
          molecule.add(O, H1, H2);
          molecule.add(createBond(O.position, H1.position));
          molecule.add(createBond(O.position, H2.position));
          break;
          
        case 'methane': // CH4
          const C_meth = createAtom(colors.C, 0.35);
          const H_meth = [
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25)
          ];
          
          // Tetrahedral geometry
          H_meth[0].position.set(0.6, 0.6, 0.6);
          H_meth[1].position.set(-0.6, -0.6, 0.6);
          H_meth[2].position.set(-0.6, 0.6, -0.6);
          H_meth[3].position.set(0.6, -0.6, -0.6);
          
          molecule.add(C_meth);
          H_meth.forEach(h => {
            molecule.add(h);
            molecule.add(createBond(C_meth.position, h.position));
          });
          break;
          
        case 'ammonia': // NH3
          const N = createAtom(colors.N, 0.35);
          const H_am = [
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25)
          ];
          
          // Trigonal pyramidal
          H_am[0].position.set(0, 0.6, 0.5);
          H_am[1].position.set(0.5, 0.6, -0.25);
          H_am[2].position.set(-0.5, 0.6, -0.25);
          
          molecule.add(N);
          H_am.forEach(h => {
            molecule.add(h);
            molecule.add(createBond(N.position, h.position));
          });
          break;
          
        case 'co2': // CO2
          const C_co2 = createAtom(colors.C, 0.35);
          const O1_co2 = createAtom(colors.O, 0.4);
          const O2_co2 = createAtom(colors.O, 0.4);
          
          O1_co2.position.set(-0.8, 0, 0);
          O2_co2.position.set(0.8, 0, 0);
          
          molecule.add(C_co2, O1_co2, O2_co2);
          molecule.add(createBond(C_co2.position, O1_co2.position));
          molecule.add(createBond(C_co2.position, O2_co2.position));
          break;
          
        case 'benzene': // C6H6
          const angleStep = (Math.PI * 2) / 6;
          const radius = 0.7;
          
          for (let i = 0; i < 6; i++) {
            const angle = i * angleStep;
            const C = createAtom(colors.C, 0.3);
            const H = createAtom(colors.H, 0.22);
            
            C.position.set(
              Math.cos(angle) * radius,
              Math.sin(angle) * radius,
              0
            );
            
            H.position.set(
              Math.cos(angle) * (radius + 0.5),
              Math.sin(angle) * (radius + 0.5),
              0
            );
            
            molecule.add(C, H);
            molecule.add(createBond(C.position, H.position));
            
            // Bond to next carbon
            const nextAngle = ((i + 1) % 6) * angleStep;
            const nextC = new THREE.Vector3(
              Math.cos(nextAngle) * radius,
              Math.sin(nextAngle) * radius,
              0
            );
            molecule.add(createBond(C.position, nextC));
          }
          break;
          
        case 'ethanol': // C2H5OH
          const C1_eth = createAtom(colors.C, 0.35);
          const C2_eth = createAtom(colors.C, 0.35);
          const O_eth = createAtom(colors.O, 0.4);
          const H_eth = [
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25),
            createAtom(colors.H, 0.25)
          ];
          
          C1_eth.position.set(-0.5, 0, 0);
          C2_eth.position.set(0.5, 0, 0);
          O_eth.position.set(1.2, 0.3, 0);
          
          H_eth[0].position.set(-0.5, 0.5, 0.4);
          H_eth[1].position.set(-0.5, 0.5, -0.4);
          H_eth[2].position.set(-0.9, -0.4, 0);
          H_eth[3].position.set(0.5, -0.5, 0.4);
          H_eth[4].position.set(0.5, -0.5, -0.4);
          H_eth[5].position.set(1.6, 0, 0.3);
          
          molecule.add(C1_eth, C2_eth, O_eth);
          H_eth.forEach(h => molecule.add(h));
          
          molecule.add(createBond(C1_eth.position, C2_eth.position));
          molecule.add(createBond(C2_eth.position, O_eth.position));
          molecule.add(createBond(C1_eth.position, H_eth[0].position));
          molecule.add(createBond(C1_eth.position, H_eth[1].position));
          molecule.add(createBond(C1_eth.position, H_eth[2].position));
          molecule.add(createBond(C2_eth.position, H_eth[3].position));
          molecule.add(createBond(C2_eth.position, H_eth[4].position));
          molecule.add(createBond(O_eth.position, H_eth[5].position));
          break;
      }
      
      mesh = molecule;
      scene.add(mesh);
      
    } else {
      // Create geometry based on type (optimized for performance)
      switch (sceneType) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(1.5, 32, 32);
          break;
        case 'torus':
          geometry = new THREE.TorusGeometry(1.2, 0.4, 16, 64);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(1, 1, 2.5, 32);
          break;
        case 'cone':
          geometry = new THREE.ConeGeometry(1.2, 2.5, 32);
          break;
        case 'octahedron':
          geometry = new THREE.OctahedronGeometry(1.5);
          break;
        case 'tetrahedron':
          geometry = new THREE.TetrahedronGeometry(1.5);
          break;
        case 'dodecahedron':
          geometry = new THREE.DodecahedronGeometry(1.3);
          break;
        case 'icosahedron':
          geometry = new THREE.IcosahedronGeometry(1.5);
          break;
        default:
          geometry = new THREE.BoxGeometry(2, 2, 2);
      }
      
      // Enhanced material for better visibility
      const material = new THREE.MeshPhongMaterial({
        color: 0x4a90e2,
        shininess: 150,
        specular: 0x888888,
        flatShading: false,
        emissive: 0x0a2540,
        emissiveIntensity: 0.15
      });
      
      const geometryMesh = new THREE.Mesh(geometry, material);
      // Disable frustum culling to prevent disappearing
      geometryMesh.frustumCulled = false;
      
      // Add edges for better definition
      edges = new THREE.EdgesGeometry(geometry);
      lineMaterial = new THREE.LineBasicMaterial({ 
        color: 0x1a1a1a, 
        linewidth: 1,
        transparent: true,
        opacity: 0.3
      });
      wireframe = new THREE.LineSegments(edges, lineMaterial);
      wireframe.frustumCulled = false;
      geometryMesh.add(wireframe);
      
      mesh = geometryMesh;
      scene.add(mesh);
    }
    
    // Mouse and Touch interaction
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let autoRotate = true;
    let initialPinchDistance = 0;
    
    const onMouseDown = (e: MouseEvent) => {
      isDragging = true;
      autoRotate = false;
      previousMousePosition = { x: e.clientX, y: e.clientY };
      container.style.cursor = 'grabbing';
    };
    
    const onMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      
      mesh.rotation.x += deltaY * 0.005;
      mesh.rotation.y += deltaX * 0.005;
      
      previousMousePosition = { x: e.clientX, y: e.clientY };
    };
    
    // Mouse up event
    const onMouseUp = () => {
      isDragging = false;
      container.style.cursor = 'grab';
    };
    
    // Touch events for mobile
    const onTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        // Single finger - rotate
        isDragging = true;
        autoRotate = false;
        previousMousePosition = { 
          x: e.touches[0].clientX, 
          y: e.touches[0].clientY 
        };
      } else if (e.touches.length === 2) {
        // Two fingers - pinch to zoom
        isDragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    };
    
    const onTouchMove = (e: TouchEvent) => {
      e.preventDefault(); // Prevent scrolling
      
      if (e.touches.length === 1 && isDragging) {
        // Single finger - rotate
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;
        
        mesh.rotation.x += deltaY * 0.005;
        mesh.rotation.y += deltaX * 0.005;
        
        previousMousePosition = { 
          x: e.touches[0].clientX, 
          y: e.touches[0].clientY 
        };
      } else if (e.touches.length === 2) {
        // Two fingers - pinch to zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const delta = distance - initialPinchDistance;
        camera.position.z -= delta * 0.01;
        camera.position.z = Math.max(2, Math.min(10, camera.position.z));
        
        initialPinchDistance = distance;
      }
    };
    
    const onTouchEnd = () => {
      isDragging = false;
      initialPinchDistance = 0;
    };
    
    container.addEventListener('mousedown', onMouseDown);
    container.addEventListener('mousemove', onMouseMove, { passive: true });
    container.addEventListener('mouseup', onMouseUp);
    container.addEventListener('mouseleave', onMouseUp);
    
    // Add touch event listeners
    container.addEventListener('touchstart', onTouchStart, { passive: true });
    container.addEventListener('touchmove', onTouchMove, { passive: false });
    container.addEventListener('touchend', onTouchEnd, { passive: true });
    container.addEventListener('touchcancel', onTouchEnd, { passive: true });
    
    // Double click/tap to reset auto-rotation
    const onDoubleClick = () => {
      autoRotate = !autoRotate;
    };
    container.addEventListener('dblclick', onDoubleClick);
    
    // Mouse wheel for zoom
    const onWheel = (e: WheelEvent) => {
      e.preventDefault();
      camera.position.z += e.deltaY * 0.001;
      camera.position.z = Math.max(2, Math.min(10, camera.position.z));
    };
    
    container.addEventListener('wheel', onWheel, { passive: false });
    
    // Set initial cursor
    container.style.cursor = 'grab';
    
    // Background toggle button
    const bgToggleBtn = wrapper.querySelector('.bg-toggle-btn') as HTMLElement;
    bgToggleBtn.addEventListener('click', () => {
      bgMode = (bgMode + 1) % bgColors.length;
      scene.background = new THREE.Color(bgColors[bgMode]);
    });
    
    // FPS counter - simple
    const fpsCounter = wrapper.querySelector('.fps-value') as HTMLElement;
    let fpsFrames = 0;
    let fpsLastTime = performance.now();
    
    function updateFPS() {
      fpsFrames++;
      const currentTime = performance.now();
      
      if (currentTime >= fpsLastTime + 1000) {
        const fps = Math.round((fpsFrames * 1000) / (currentTime - fpsLastTime));
        fpsCounter.textContent = fps.toString();
        fpsFrames = 0;
        fpsLastTime = currentTime;
      }
    }
    
    // Animation - simple
    function animate() {
      requestAnimationFrame(animate);
      
      if (autoRotate && !isDragging) {
        mesh.rotation.x += 0.003;
        mesh.rotation.y += 0.006;
      }
      
      renderer.render(scene, camera);
      updateFPS();
    }
    
    animate();
    
    // Handle window resize with throttling
    let resizeTimeout;
    const resizeHandler = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }, 100); // Throttle to 100ms
    };
    
    window.addEventListener('resize', resizeHandler);
    
    // Cleanup function to prevent memory leaks
    const cleanup = () => {
      // Dispose geometries
      if (geometry) geometry.dispose();
      if (edges) edges.dispose();
      
      // Dispose materials
      if (lineMaterial) lineMaterial.dispose();
      
      // Dispose molecule geometries and materials
      if (isMolecule && mesh) {
        mesh.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            child.geometry?.dispose();
            if (child.material instanceof THREE.Material) {
              child.material.dispose();
            }
          }
        });
      }
      
      // Dispose renderer
      renderer.dispose();
      
      // Remove event listeners
      window.removeEventListener('resize', resizeHandler);
      container.removeEventListener('mousedown', onMouseDown);
      container.removeEventListener('mousemove', onMouseMove, { passive: true } as any);
      container.removeEventListener('mouseup', onMouseUp);
      container.removeEventListener('mouseleave', onMouseUp);
      container.removeEventListener('touchstart', onTouchStart, { passive: true } as any);
      container.removeEventListener('touchmove', onTouchMove, { passive: false } as any);
      container.removeEventListener('touchend', onTouchEnd, { passive: true } as any);
      container.removeEventListener('touchcancel', onTouchEnd, { passive: true } as any);
      container.removeEventListener('dblclick', onDoubleClick);
      container.removeEventListener('wheel', onWheel, { passive: false } as any);
    };
    
    // Store cleanup for potential future use
    Object.defineProperty(container, '__cleanup', {
      value: cleanup,
      writable: false,
      enumerable: false,
      configurable: true
    });
  });
</script>

<style>
  .three-wrapper {
    position: relative;
    margin: 2rem 0;
  }
  
  .bg-toggle-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    color: #24292f;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  .bg-toggle-btn:hover {
    background: white;
    border-color: #24292f;
    transform: scale(1.05);
  }
  
  .bg-toggle-btn:active {
    transform: scale(0.95);
  }
  
  .fps-counter {
    position: absolute;
    top: 1rem;
    left: 1rem;
    z-index: 10;
    background: rgba(0, 0, 0, 0.7);
    color: #00ff00;
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 0.875rem;
    font-weight: bold;
    pointer-events: none;
    backdrop-filter: blur(4px);
  }
  
  .fps-value {
    color: #00ff00;
    min-width: 2ch;
    display: inline-block;
    text-align: right;
  }

  .three-container {
    width: 100%;
    border-radius: 8px;
    overflow: visible;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    position: relative;
    /* Force GPU compositing for WebKit browsers (Chrome/Safari) */
    transform: translateZ(0);
    -webkit-transform: translateZ(0);
    will-change: transform;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  .three-container canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
    position: relative;
    touch-action: none;
    /* Force GPU layer for canvas in WebKit */
    transform: translate3d(0, 0, 0);
    -webkit-transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }
</style>

