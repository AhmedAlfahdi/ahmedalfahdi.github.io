---
interface Props {
  sceneType?: 'cube' | 'sphere' | 'torus';
  height?: string;
}

const { sceneType = 'cube', height = '500px' } = Astro.props;
const sceneId = `scene-${Math.random().toString(36).substr(2, 9)}`;
---

<div id={sceneId} class="three-wrapper">
  <button class="bg-toggle-btn" title="Toggle Background">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
      <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
    </svg>
  </button>
  <div class="three-container" style={`height: ${height}`} data-scene-type={sceneType}></div>
</div>

<script>
  import * as THREE from 'three';

  // Find all three wrappers and initialize them
  document.querySelectorAll('.three-wrapper').forEach((wrapperEl: Element) => {
    const wrapper = wrapperEl as HTMLElement;
    const container = wrapper.querySelector('.three-container') as HTMLElement;
    const sceneType = container.dataset.sceneType || 'cube';
    
    // Skip if already initialized
    if (container.querySelector('canvas')) return;
    
    // Scene setup
    const scene = new THREE.Scene();
    
    // Background toggle state (0: light, 1: dark)
    let bgMode = 0;
    const bgColors = [0xf0f0f0, 0x1a1a2e]; // light, dark
    scene.background = new THREE.Color(bgColors[0]);
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 5;
    
    // Renderer setup with performance optimizations
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false,
      powerPreference: 'high-performance',
      stencil: false, // Disable stencil buffer if not needed
      depth: true
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
    renderer.setSize(container.clientWidth, container.clientHeight);
    
    // Enable frustum culling (default but explicit)
    camera.matrixWorldNeedsUpdate = true;
    
    container.appendChild(renderer.domElement);
    
    // Clock for frame-rate independent animation
    const clock = new THREE.Clock();
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);
    
    // Create geometry based on type (reduced complexity for performance)
    let geometry;
    switch (sceneType) {
      case 'sphere':
        geometry = new THREE.SphereGeometry(1.5, 24, 24); // Reduced from 32x32
        break;
      case 'torus':
        geometry = new THREE.TorusGeometry(1.2, 0.4, 12, 48); // Reduced from 16x100
        break;
      default:
        geometry = new THREE.BoxGeometry(2, 2, 2);
    }
    
    const material = new THREE.MeshPhongMaterial({
      color: 0x3498db,
      shininess: 100,
      specular: 0x111111,
      flatShading: false // Smooth shading for better performance
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.matrixAutoUpdate = true; // Enable automatic matrix updates
    scene.add(mesh);
    
    // Mouse interaction variables
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotationVelocity = { x: 0, y: 0 };
    let autoRotate = true;
    
    // Mouse down event
    container.addEventListener('mousedown', (e) => {
      isDragging = true;
      autoRotate = false;
      previousMousePosition = { x: e.clientX, y: e.clientY };
      container.style.cursor = 'grabbing';
    });
    
    // Mouse move event
    container.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        rotationVelocity.x = deltaY * 0.01;
        rotationVelocity.y = deltaX * 0.01;
        
        mesh.rotation.x += rotationVelocity.x;
        mesh.rotation.y += rotationVelocity.y;
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });
    
    // Mouse up event
    container.addEventListener('mouseup', () => {
      isDragging = false;
      container.style.cursor = 'grab';
    });
    
    // Mouse leave event
    container.addEventListener('mouseleave', () => {
      isDragging = false;
      container.style.cursor = 'grab';
    });
    
    // Double click to reset auto-rotation
    container.addEventListener('dblclick', () => {
      autoRotate = !autoRotate;
    });
    
    // Mouse wheel for zoom
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomSpeed = 0.001;
      camera.position.z += e.deltaY * zoomSpeed;
      camera.position.z = Math.max(2, Math.min(10, camera.position.z));
    }, { passive: false });
    
    // Set initial cursor
    container.style.cursor = 'grab';
    
    // Background toggle button
    const bgToggleBtn = wrapper.querySelector('.bg-toggle-btn') as HTMLElement;
    bgToggleBtn.addEventListener('click', () => {
      bgMode = (bgMode + 1) % bgColors.length;
      scene.background = new THREE.Color(bgColors[bgMode]);
    });
    
    // Pause when not visible (Intersection Observer)
    let isVisible = true;
    let animationId = null;
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
        if (!isVisible && animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        } else if (isVisible && !animationId) {
          animate();
        }
      });
    }, { threshold: 0.1 });
    
    observer.observe(container);
    
    // Frame rate limiting
    const targetFPS = 60;
    const frameInterval = 1000 / targetFPS;
    let lastFrameTime = 0;
    
    // Animation
    function animate(currentTime = 0) {
      if (!isVisible) return;
      
      animationId = requestAnimationFrame(animate);
      
      // Throttle to target FPS
      const elapsed = currentTime - lastFrameTime;
      if (elapsed < frameInterval) return;
      
      lastFrameTime = currentTime - (elapsed % frameInterval);
      
      // Get delta time for frame-rate independent animation
      const delta = clock.getDelta();
      
      // Auto-rotate when not dragging (frame-rate independent)
      if (autoRotate && !isDragging) {
        const rotationSpeed = 1.0; // radians per second
        mesh.rotation.x += rotationSpeed * delta * 0.3;
        mesh.rotation.y += rotationSpeed * delta * 0.6;
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Handle window resize with throttling
    let resizeTimeout;
    const resizeHandler = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }, 100); // Throttle to 100ms
    };
    
    window.addEventListener('resize', resizeHandler);
    
    // Cleanup function to prevent memory leaks
    const cleanup = () => {
      // Dispose geometries
      geometry.dispose();
      
      // Dispose materials
      material.dispose();
      
      // Dispose renderer
      renderer.dispose();
      
      // Remove event listeners
      window.removeEventListener('resize', resizeHandler);
      observer.disconnect();
    };
    
    // Store cleanup for potential future use
    (container as any).__cleanup = cleanup;
  });
</script>

<style>
  .three-wrapper {
    position: relative;
    margin: 2rem 0;
  }
  
  .bg-toggle-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    color: #24292f;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  .bg-toggle-btn:hover {
    background: white;
    border-color: #24292f;
    transform: scale(1.05);
  }
  
  .bg-toggle-btn:active {
    transform: scale(0.95);
  }

  .three-container {
    width: 100%;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  .three-container canvas {
    display: block;
  }
</style>

