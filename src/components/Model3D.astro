---
interface Props {
  src: string;
  height?: string;
  scale?: number;
  position?: [number, number, number];
  rotation?: [number, number, number];
  autoRotate?: boolean;
  background?: string;
}

const { 
  src, 
  height = '500px', 
  scale = 1,
  position = [0, 0, 0],
  rotation = [0, 0, 0],
  autoRotate = true,
  background = 'default'
} = Astro.props;

const containerId = `model3d-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="model3d-wrapper" id={containerId}>
  <button class="bg-toggle-btn" title="Toggle Background">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
      <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
      <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
    </svg>
  </button>
  <div class="fps-counter">FPS: <span class="fps-value">--</span></div>
  <div 
    class="model3d-container" 
    style={`height: ${height}`}
    data-src={src}
    data-scale={scale}
    data-position={JSON.stringify(position)}
    data-rotation={JSON.stringify(rotation)}
    data-auto-rotate={autoRotate}
    data-background={background}
  >
    <div class="loading-indicator">Loading 3D model...</div>
  </div>
</div>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
  
  // Check WebGL support
  function isWebGLAvailable() {
    try {
      const canvas = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && 
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
      return false;
    }
  }
  
  document.querySelectorAll('.model3d-wrapper').forEach(async (wrapperEl: Element) => {
    const wrapper = wrapperEl as HTMLElement;
    const container = wrapper.querySelector('.model3d-container') as HTMLElement;
    const loadingIndicator = container.querySelector('.loading-indicator') as HTMLElement;
    
    // Skip if already initialized
    if (container.querySelector('canvas')) return;
    
    // Check WebGL support
    if (!isWebGLAvailable()) {
      loadingIndicator.textContent = 'WebGL is not supported in your browser. Please use a modern browser to view 3D models.';
      loadingIndicator.style.color = '#e74c3c';
      return;
    }
    
    // Get configuration from data attributes
    const src = container.dataset.src!;
    const scale = parseFloat(container.dataset.scale || '1');
    const position = JSON.parse(container.dataset.position || '[0,0,0]');
    const rotation = JSON.parse(container.dataset.rotation || '[0,0,0]');
    const autoRotate = container.dataset.autoRotate === 'true';
    const bgColor = container.dataset.background || 'default';
    
    // Scene setup
    const scene = new THREE.Scene();
    const isDark = document.documentElement.classList.contains('dark');
    
    // Background toggle state (0: light, 1: dark)
    let bgMode = 0;
    const bgColors = bgColor === 'transparent' ? [null, null] : [0xf0f0f0, 0x1a1a2e]; // light, dark
    
    // Set initial background
    if (bgColor === 'transparent') {
      scene.background = null;
    } else if (bgColor === 'default') {
      scene.background = new THREE.Color(bgColors[0] as number);
    } else {
      scene.background = new THREE.Color(bgColor);
    }
    
    // Camera
    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 5);
    
    // Renderer - simple and clean
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: bgColor === 'transparent',
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = false;
    
    // Lighting - optimized for performance
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
    scene.add(ambientLight);
    
    // Use DirectionalLight instead of PointLight for better performance
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    
    // Load model with retry logic and better error handling
    let model: THREE.Object3D;
    const fileExtension = src.split('.').pop()?.toLowerCase();
    
    // Helper function to load with timeout
    async function loadWithTimeout(loaderFunc: () => Promise<any>, timeoutMs = 30000) {
      return Promise.race([
        loaderFunc(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Loading timeout - check your internet connection')), timeoutMs)
        )
      ]);
    }
    
    // Helper function to retry loading
    async function loadWithRetry(loaderFunc: () => Promise<any>, maxRetries = 2) {
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          if (attempt > 0) {
            loadingIndicator.textContent = `Retrying... (${attempt}/${maxRetries})`;
          }
          return await loadWithTimeout(loaderFunc, 30000);
        } catch (error) {
          if (attempt === maxRetries) throw error;
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    }
    
    try {
      if (fileExtension === 'gltf' || fileExtension === 'glb') {
        const loader = new GLTFLoader();
        const gltf = await loadWithRetry(() => loader.loadAsync(src));
        model = gltf.scene;
      } else if (fileExtension === 'obj') {
        const loader = new OBJLoader();
        model = await loadWithRetry(() => loader.loadAsync(src));
      } else {
        throw new Error(`Unsupported file format: ${fileExtension}`);
      }
      
      // Apply transformations
      model.scale.set(scale, scale, scale);
      model.position.set(position[0], position[1], position[2]);
      model.rotation.set(rotation[0], rotation[1], rotation[2]);
      
      // Optimize materials for performance
      model.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          // Disable frustum culling to prevent models from disappearing during scroll
          // This is especially important on mobile where viewport calculations can be unreliable
          child.frustumCulled = false;
          child.matrixAutoUpdate = true;
          
          // Optimize material if it's a standard/physical material
          if (child.material) {
            const mat = child.material;
            if ('envMapIntensity' in mat) mat.envMapIntensity = 0.5;
          }
        }
      });
      
      // Center the model
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.x -= center.x;
      model.position.y -= center.y;
      model.position.z -= center.z;
      
      // Adjust camera based on model size
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      camera.position.z = maxDim * 2;
      
      scene.add(model);
      
      // Hide loading indicator and show canvas
      loadingIndicator.style.display = 'none';
      container.appendChild(renderer.domElement);
      
    } catch (error) {
      console.error('Error loading 3D model:', error);
      const errorMsg = error.message || 'Unknown error';
      
      // Provide more helpful error messages
      if (errorMsg.includes('timeout')) {
        loadingIndicator.textContent = 'Loading timeout. Please check your internet connection and try refreshing.';
      } else if (errorMsg.includes('404') || errorMsg.includes('not found')) {
        loadingIndicator.textContent = 'Model file not found. Please check the file path.';
      } else if (errorMsg.includes('memory') || errorMsg.includes('out of memory')) {
        loadingIndicator.textContent = 'Not enough memory to load this model. Try closing other tabs.';
      } else {
        loadingIndicator.textContent = `Error loading model: ${errorMsg}`;
      }
      
      loadingIndicator.style.color = '#e74c3c';
      loadingIndicator.style.fontSize = '0.9rem';
      return;
    }
    
    // Mouse and Touch interaction
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let initialPinchDistance = 0;
    
    const onMouseDown = (e: MouseEvent) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
      container.style.cursor = 'grabbing';
    };
    
    const onMouseMove = (e: MouseEvent) => {
      if (!isDragging || !model) return;
      
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      
      model.rotation.y += deltaX * 0.005;
      model.rotation.x += deltaY * 0.005;
      
      previousMousePosition = { x: e.clientX, y: e.clientY };
    };
    
    const onMouseUp = () => {
      isDragging = false;
      container.style.cursor = 'grab';
    };
    
    // Touch events for mobile
    const onTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        // Single finger - rotate
        isDragging = true;
        previousMousePosition = { 
          x: e.touches[0].clientX, 
          y: e.touches[0].clientY 
        };
      } else if (e.touches.length === 2) {
        // Two fingers - pinch to zoom
        isDragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    };
    
    const onTouchMove = (e: TouchEvent) => {
      e.preventDefault(); // Prevent scrolling
      
      if (e.touches.length === 1 && isDragging && model) {
        // Single finger - rotate
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;
        
        model.rotation.y += deltaX * 0.005;
        model.rotation.x += deltaY * 0.005;
        
        previousMousePosition = { 
          x: e.touches[0].clientX, 
          y: e.touches[0].clientY 
        };
      } else if (e.touches.length === 2) {
        // Two fingers - pinch to zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const delta = distance - initialPinchDistance;
        camera.position.z -= delta * 0.01;
        camera.position.z = Math.max(1, Math.min(20, camera.position.z));
        
        initialPinchDistance = distance;
      }
    };
    
    const onTouchEnd = () => {
      isDragging = false;
      initialPinchDistance = 0;
    };
    
    container.addEventListener('mousedown', onMouseDown);
    container.addEventListener('mousemove', onMouseMove, { passive: true });
    container.addEventListener('mouseup', onMouseUp);
    container.addEventListener('mouseleave', onMouseUp);
    
    // Add touch event listeners
    container.addEventListener('touchstart', onTouchStart, { passive: true });
    container.addEventListener('touchmove', onTouchMove, { passive: false });
    container.addEventListener('touchend', onTouchEnd, { passive: true });
    container.addEventListener('touchcancel', onTouchEnd, { passive: true });
    
    // Zoom with mouse wheel
    const onWheel = (e: WheelEvent) => {
      e.preventDefault();
      camera.position.z += e.deltaY * 0.001;
      camera.position.z = Math.max(1, Math.min(20, camera.position.z));
    };
    
    container.addEventListener('wheel', onWheel, { passive: false });
    
    container.style.cursor = 'grab';
    
    // Background toggle button
    const bgToggleBtn = wrapper.querySelector('.bg-toggle-btn') as HTMLElement;
    if (bgToggleBtn && bgColor !== 'transparent') {
      bgToggleBtn.addEventListener('click', () => {
        bgMode = (bgMode + 1) % bgColors.length;
        if (bgColors[bgMode] !== null) {
          scene.background = new THREE.Color(bgColors[bgMode] as number);
        } else {
          scene.background = null;
        }
      });
    }
    
    // FPS counter - simple
    const fpsCounter = wrapper.querySelector('.fps-value') as HTMLElement;
    let fpsFrames = 0;
    let fpsLastTime = performance.now();
    
    function updateFPS() {
      fpsFrames++;
      const currentTime = performance.now();
      
      if (currentTime >= fpsLastTime + 1000) {
        const fps = Math.round((fpsFrames * 1000) / (currentTime - fpsLastTime));
        fpsCounter.textContent = fps.toString();
        fpsFrames = 0;
        fpsLastTime = currentTime;
      }
    }
    
    // Animation loop - simple
    function animate() {
      requestAnimationFrame(animate);
      
      if (autoRotate && !isDragging && model) {
        model.rotation.y += 0.005;
      }
      
      renderer.render(scene, camera);
      updateFPS();
    }
    
    animate();
    
    // Handle resize
    let resizeTimeout;
    const resizeHandler = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }, 100);
    };
    
    // Handle visibility changes (important for mobile scrolling)
    // Force render when container becomes visible again
    let visibilityObserver: IntersectionObserver | null = null;
    if ('IntersectionObserver' in window) {
      visibilityObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && model) {
            // Force a render when the model becomes visible
            renderer.render(scene, camera);
          }
        });
      }, {
        threshold: 0.01, // Trigger when even 1% is visible
        rootMargin: '50px' // Start rendering slightly before it's visible
      });
      
      visibilityObserver.observe(container);
    }
    
    // Force rendering during scroll (critical for Chrome mobile)
    let scrollTimeout: number;
    let isScrolling = false;
    const forceRenderOnScroll = () => {
      if (!isScrolling) {
        isScrolling = true;
      }
      // Force render immediately
      if (model) {
        renderer.render(scene, camera);
      }
      
      // Clear timeout and set a new one
      clearTimeout(scrollTimeout);
      scrollTimeout = window.setTimeout(() => {
        isScrolling = false;
      }, 150);
    };
    
    // Add scroll listener with passive flag for performance
    window.addEventListener('scroll', forceRenderOnScroll, { passive: true });
    
    // Also listen to touch events for mobile
    let touchTimeout: number;
    const forceRenderOnTouch = () => {
      if (model) {
        renderer.render(scene, camera);
      }
      clearTimeout(touchTimeout);
      touchTimeout = window.setTimeout(() => {
        renderer.render(scene, camera);
      }, 50);
    };
    
    container.addEventListener('touchmove', forceRenderOnTouch, { passive: true });
    
    // Handle WebGL context loss (common on mobile)
    const canvas = renderer.domElement;
    canvas.addEventListener('webglcontextlost', (event) => {
      event.preventDefault();
      console.warn('WebGL context lost');
      loadingIndicator.textContent = 'Graphics context lost. Refreshing page...';
      loadingIndicator.style.display = 'block';
      loadingIndicator.style.color = '#f39c12';
      
      // Attempt to restore after a short delay
      setTimeout(() => {
        window.location.reload();
      }, 2000);
    }, false);
    
    canvas.addEventListener('webglcontextrestored', () => {
      console.log('WebGL context restored');
      loadingIndicator.style.display = 'none';
    }, false);
    
    window.addEventListener('resize', resizeHandler);
    
    // Cleanup function to prevent memory leaks
    const cleanup = () => {
      // Dispose model
      if (model) {
        model.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            if (child.geometry) {
              child.geometry.dispose();
            }
            if (child.material) {
              const materials = Array.isArray(child.material) 
                ? child.material 
                : [child.material];
              materials.forEach((mat) => {
                // Dispose textures
                if ('map' in mat && mat.map) mat.map.dispose();
                if ('lightMap' in mat && mat.lightMap) mat.lightMap.dispose();
                if ('bumpMap' in mat && mat.bumpMap) mat.bumpMap.dispose();
                if ('normalMap' in mat && mat.normalMap) mat.normalMap.dispose();
                if ('specularMap' in mat && mat.specularMap) mat.specularMap.dispose();
                if ('envMap' in mat && mat.envMap) mat.envMap.dispose();
                mat.dispose();
              });
            }
          }
        });
      }
      
      // Dispose renderer
      renderer.dispose();
      
      // Disconnect intersection observer
      if (visibilityObserver) {
        visibilityObserver.disconnect();
      }
      
      // Remove event listeners
      window.removeEventListener('resize', resizeHandler);
      window.removeEventListener('scroll', forceRenderOnScroll, { passive: true } as any);
      container.removeEventListener('mousedown', onMouseDown);
      container.removeEventListener('mousemove', onMouseMove, { passive: true } as any);
      container.removeEventListener('mouseup', onMouseUp);
      container.removeEventListener('mouseleave', onMouseUp);
      container.removeEventListener('touchstart', onTouchStart, { passive: true } as any);
      container.removeEventListener('touchmove', onTouchMove, { passive: false } as any);
      container.removeEventListener('touchmove', forceRenderOnTouch, { passive: true } as any);
      container.removeEventListener('touchend', onTouchEnd, { passive: true } as any);
      container.removeEventListener('touchcancel', onTouchEnd, { passive: true } as any);
      container.removeEventListener('wheel', onWheel);
      
      // Remove WebGL context event listeners
      if (canvas) {
        canvas.removeEventListener('webglcontextlost', () => {});
        canvas.removeEventListener('webglcontextrestored', () => {});
      }
    };
    
    // Store cleanup for potential future use
    Object.defineProperty(container, '__cleanup', {
      value: cleanup,
      writable: false,
      enumerable: false,
      configurable: true
    });
  });
</script>

<style>
  .model3d-wrapper {
    position: relative;
    margin: 2rem 0;
  }
  
  .bg-toggle-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 0.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    color: #24292f;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  .bg-toggle-btn:hover {
    background: white;
    border-color: #24292f;
    transform: scale(1.05);
  }
  
  .bg-toggle-btn:active {
    transform: scale(0.95);
  }
  
  .fps-counter {
    position: absolute;
    top: 1rem;
    left: 1rem;
    z-index: 10;
    background: rgba(0, 0, 0, 0.7);
    color: #00ff00;
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 0.875rem;
    font-weight: bold;
    pointer-events: none;
    backdrop-filter: blur(4px);
  }
  
  .fps-value {
    color: #00ff00;
    min-width: 2ch;
    display: inline-block;
    text-align: right;
  }

  .model3d-container {
    width: 100%;
    border-radius: 8px;
    overflow: visible;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    position: relative;
    display: block;
    background: #1a1a2e;
    min-height: 400px;
    /* Force GPU compositing for WebKit browsers (Chrome/Safari) */
    transform: translateZ(0);
    -webkit-transform: translateZ(0);
    will-change: transform;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  .model3d-container canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
    position: relative;
    touch-action: none;
    /* Force GPU layer for canvas in WebKit */
    transform: translate3d(0, 0, 0);
    -webkit-transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }
  
  .loading-indicator {
    color: white;
    font-size: 1rem;
    text-align: center;
    padding: 2rem;
  }
</style>

