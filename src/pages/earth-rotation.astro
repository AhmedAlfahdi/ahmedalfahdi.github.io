---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Earth Rotation & Universal Time">
  <div class="container">
    <a href="/" class="back-link">← Back Home</a>
    <article class="content">
      <h1>Earth Rotation & Universal Time</h1>
      <p class="intro">
        An interactive exploration of Earth's rotation, time standards, and the relationship between atomic time (UTC) and astronomical time (UT1). Use the 3D globe and calculator to understand how Earth's rotation defines our timekeeping systems.
      </p>

      <section>
        <h2>What Are UTC and UT1?</h2>
        <p>
          <strong>UTC (Coordinated Universal Time)</strong> is the global time standard used by computers, networks, and civil timekeeping worldwide. It is based on extremely precise atomic clocks (TAI - International Atomic Time) that maintain uniform seconds independent of Earth's rotation.
        </p>
        <p>
          <strong>UT1 (Universal Time)</strong> is a time scale directly tied to Earth's actual rotation. It measures the rotation angle of Earth relative to distant celestial objects. Unlike UTC's uniform atomic seconds, UT1 reflects the slightly irregular rotation of our planet.
        </p>
        <p>
          <strong>DUT1 (Delta UT1)</strong> is the difference: DUT1 = UT1 − UTC. The International Earth Rotation and Reference Systems Service (IERS) publishes DUT1 values to keep the two time scales synchronized. When |DUT1| approaches ±0.9 seconds, a leap second is added to or removed from UTC to bring it back in alignment with UT1.
        </p>
      </section>

      <section class="viewer">
        <h2>3D Globe (Earth rotation)</h2>
        <div id="globe-3d" class="globe-3d">
          <div class="globe-status" id="globe-status">Loading…</div>
          <button id="fullscreen-btn" class="fullscreen-btn" title="Fullscreen (F)">Fullscreen</button>
        </div>
        
        <div class="globe-info-row">
          <div class="globe-legend">
            <div class="legend-title">Legend</div>
            <div class="legend-item">
              <span class="legend-color" style="background: #2c6ead; border: 1px solid #2c6ead;"></span>
              <span>Wireframe Earth with 30° grid (rotates)</span>
            </div>
            <div class="legend-item">
              <span class="legend-color" style="background: #f5a524;"></span>
              <span>Greenwich Meridian (0° longitude)</span>
            </div>
            <div class="legend-item">
              <span class="legend-color" style="background: rgba(245,165,36,0.5);"></span>
              <span>Equator (0° latitude)</span>
            </div>
            <div class="legend-item">
              <span class="legend-color legend-dashed" style="background: #9ea7b3;"></span>
              <span>Rotation Axis (fixed, N/S labeled)</span>
            </div>
            <div class="legend-item">
              <span class="legend-color" style="background: linear-gradient(90deg, #ff4444 0%, #44ff44 20%, #4444ff 40%, #ffff44 60%, #ff44ff 80%, #44ffff 100%);"></span>
              <span>Major Cities (London, NYC, Tokyo, Sydney, Cairo, Muscat)</span>
            </div>
            <div class="legend-item">
              <span class="legend-color" style="background: #ffcc00; box-shadow: 0 0 8px #ffcc00;"></span>
              <span>Sun Direction (based on solar angle)</span>
            </div>
          </div>
          
          <div class="globe-meta" id="globe-meta">
            <div class="meta-title">Physical Properties</div>
            <div><strong>Ω</strong> 7.2921159×10⁻⁵ rad/s</div>
            <div><strong>Sidereal day</strong> 86,164.09 s</div>
            <div><strong>Spin</strong> 15.041°/hr</div>
            <div><strong>Rₑ</strong> ≈ 6,378 km</div>
            <div id="globe-scale"><strong>Animation</strong> —</div>
          </div>
        </div>
        
        <p class="note">A 3D wireframe globe showing Earth's rotation around its axis. The prime meridian (gold line) and equator (gold ring) rotate with the Earth. The rotation axis (gray dashed line) with N and S labels remains fixed in space. Six major cities are marked with subtle colored dots to provide geographic reference. The Sun (yellow sphere) shows the direction of your calculated solar angle and updates as you change the time or longitude.</p>
        <div class="keyboard-shortcuts">
          <strong>Keyboard Shortcuts:</strong>
          <span><kbd>Space</kbd> Pause/Resume</span>
          <span><kbd>R</kbd> Reset view</span>
          <span><kbd>F</kbd> Fullscreen</span>
        </div>
      </section>

      <section class="calc">
        <h2>UT1 Calculator</h2>
        <div class="calc-grid">
          <label>
            UTC (date & time)
            <input id="utc-input" type="datetime-local" />
          </label>
          <label>
            DUT1 (seconds, from IERS)
            <input id="dut1-input" type="number" step="0.1" value="0.0" />
            <div class="small-note">Example: -0.1 (see IERS Bulletin A)</div>
            <button id="dut1-reset" type="button" class="pill">Reset DUT1</button>
          </label>
          <label>
            Longitude (degrees, east + / west -)
            <input id="lon-input" type="number" step="0.01" value="0" />
          </label>
        </div>
        <label class="inline">
          <input id="auto-utc" type="checkbox" checked />
          Auto-update UTC from system clock (updates every second)
          <span id="live-indicator" class="live-badge">LIVE</span>
        </label>
        <div class="links">
          <a href="https://datacenter.iers.org/data/latestVersion/6_BULLETIN_A_V2013_016.txt" target="_blank" rel="noreferrer">Latest DUT1 (IERS Bulletin A)</a>
        </div>
        <div class="preset-row">
          <span class="small-note">Quick longitudes:</span>
          <div class="preset-buttons">
            <button type="button" data-lon="-180" class="pill">-180</button>
            <button type="button" data-lon="-90" class="pill">-90</button>
            <button type="button" data-lon="0" class="pill">0</button>
            <button type="button" data-lon="90" class="pill">90</button>
            <button type="button" data-lon="180" class="pill">180</button>
          </div>
        </div>
        <div class="results" id="results">
          <div><strong>UTC used:</strong> <span id="utc-used">—</span></div>
          <div><strong>DUT1 applied:</strong> <span id="dut1-applied">—</span></div>
          <div><strong>UT1:</strong> <span id="ut1-val">—</span></div>
          <div><strong>Solar angle (approx):</strong> <span id="angle-val">—</span></div>
        </div>
        <p class="note">
          This is an illustrative calculation: it applies DUT1 directly to UTC and estimates solar angle from UT1 and longitude. Solar angle here is a simplified local solar angle, not GMST/GAST. For precise work, use full IERS conventions (GMST/GAST, EOP, and nutation models).
        </p>
        <p class="note">
          Why only the solar angle moves when you change longitude: UT1 is the same everywhere (it's Earth-rotation time), so changing longitude shifts your local hour angle relative to Greenwich—hence the solar angle changes, but UTC/UT1 values do not.
        </p>
      </section>

      <section>
        <h2>Time Relationships</h2>
        <p>The mathematical relationships used in this demonstration:</p>
        <ul>
          <li><strong>UT1 = UTC + DUT1</strong> where DUT1 is published by IERS (typically within ±0.9 s)</li>
          <li><strong>Mean solar day = 86,400 SI seconds</strong> - UT1 tracks Earth's rotation relative to the Sun</li>
          <li><strong>Sidereal day = 86,164.09 seconds</strong> - Earth's true rotation period relative to stars</li>
          <li><strong>Local solar angle ≈ (UT1 hours × 15°/hour) + longitude</strong> - simplified calculation for illustration</li>
        </ul>
        <p class="note">
          Note: This page uses simplified solar angle calculations for educational purposes. For precise astronomical work, use GMST/GAST (Greenwich Mean/Apparent Sidereal Time) with full IERS Earth Orientation Parameters (EOP) and nutation models.
        </p>
      </section>

      <section>
        <h2>Historical Evolution of Time Standards</h2>
        <div class="timeline">
          <div class="timeline-item">
            <div class="timeline-year">Pre-1884</div>
            <div class="timeline-content">
              <h3>Local Mean Time</h3>
              <p>Each city used its own local solar time based on the sun's position. No global coordination existed.</p>
            </div>
          </div>
          <div class="timeline-item">
            <div class="timeline-year">1884</div>
            <div class="timeline-content">
              <h3>Greenwich Mean Time (GMT)</h3>
              <p>International Meridian Conference established GMT as the world's time reference, based on mean solar time at Greenwich Observatory. The prime meridian (0° longitude) was set at Greenwich.</p>
            </div>
          </div>
          <div class="timeline-item">
            <div class="timeline-year">1960</div>
            <div class="timeline-content">
              <h3>Universal Time (UT1)</h3>
              <p>UT1 was defined as a precise measure of Earth's rotation angle, replacing GMT. Based on astronomical observations rather than the sun's apparent motion.</p>
            </div>
          </div>
          <div class="timeline-item">
            <div class="timeline-year">1972</div>
            <div class="timeline-content">
              <h3>Coordinated Universal Time (UTC)</h3>
              <p>UTC became the global time standard, based on atomic clocks (TAI) with leap seconds added to keep it synchronized with UT1. This allows for stable, precise timekeeping while staying aligned with Earth's rotation.</p>
            </div>
          </div>
        </div>
      </section>

      <section>
        <h2>Sidereal vs Solar Day</h2>
        <div class="comparison-grid">
          <div class="comparison-card">
            <h3>Sidereal Day</h3>
            <div class="comparison-value">23h 56m 4.09s</div>
            <div class="comparison-exact">86,164.09 seconds</div>
            <p>Time for Earth to rotate 360° relative to distant stars. This is Earth's true rotation period.</p>
          </div>
          <div class="comparison-card">
            <h3>Solar Day</h3>
            <div class="comparison-value">24h 0m 0s</div>
            <div class="comparison-exact">86,400 seconds</div>
            <p>Time for the Sun to return to the same position in the sky. Longer because Earth moves in its orbit around the Sun.</p>
          </div>
        </div>
        <p class="note">
          The solar day is approximately 3 minutes 56 seconds longer than the sidereal day. This difference accumulates: after one year (365.25 solar days), Earth completes 366.25 sidereal rotations. The extra rotation is why we have one more sidereal day than solar days per year.
        </p>
      </section>

      <section>
        <h2>DUT1 History & Variations</h2>
        <p>DUT1 (the difference between UT1 and UTC) varies over time as Earth's rotation fluctuates. The IERS publishes DUT1 values, and when |DUT1| approaches 0.9 seconds, a leap second is added or removed from UTC.</p>
        <div class="chart-container">
          <canvas id="dut1-chart"></canvas>
        </div>
        <p class="note">
          This chart shows approximate DUT1 values over recent years. Earth's rotation is slowing due to tidal friction, causing UT1 to gradually drift behind UTC. Leap seconds are inserted to keep them synchronized.
        </p>
      </section>

      <section>
        <h2>Leap Seconds Timeline</h2>
        <p>Since 1972, 27 leap seconds have been added to UTC to keep it within 0.9 seconds of UT1. All have been positive (UTC paused for one second), and they typically occur on June 30 or December 31.</p>
        <div class="leap-seconds-grid" id="leap-seconds-grid"></div>
        <p class="note">
          Leap seconds are controversial in computing and telecommunications because they create irregularities in otherwise uniform time. In 2022, the International Telecommunication Union voted to eliminate leap seconds by 2035, allowing UTC and UT1 to drift apart by up to one minute.
        </p>
      </section>

      <section>
        <h2>Earth's Rotation Variations</h2>
        <p>Earth's rotation is not constant. The length of day (LOD) varies due to multiple factors:</p>
        <div class="variation-grid">
          <div class="variation-card">
            <h3>Tidal Friction</h3>
            <p><strong>Effect:</strong> +1.7 ms/century</p>
            <p>Moon's gravity creates tidal bulges that slow Earth's rotation. Over geological time, days are getting longer.</p>
          </div>
          <div class="variation-card">
            <h3>Glacial Rebound</h3>
            <p><strong>Effect:</strong> -0.6 ms/century</p>
            <p>Post-ice-age crustal rebound redistributes Earth's mass, slightly speeding up rotation (like a spinning ice skater pulling in their arms).</p>
          </div>
          <div class="variation-card">
            <h3>Core-Mantle Coupling</h3>
            <p><strong>Effect:</strong> ±1-2 ms/decade</p>
            <p>Electromagnetic and gravitational interactions between Earth's liquid outer core and solid mantle cause irregular variations.</p>
          </div>
          <div class="variation-card">
            <h3>Atmospheric Winds</h3>
            <p><strong>Effect:</strong> ±0.5 ms/season</p>
            <p>Seasonal changes in atmospheric circulation transfer angular momentum, causing daily variations in Earth's rotation rate.</p>
          </div>
        </div>
        <p class="note">
          Current measurements show Earth's rotation is gradually slowing by about 1.1 milliseconds per century on average. However, recent data (2020-2024) shows Earth has been rotating slightly faster than usual, making days shorter by fractions of a millisecond.
        </p>
      </section>
    </article>
  </div>
</BaseLayout>

<script is:inline type="module">
  // Three.js globe with visible North/South poles
  (async () => {
    if (typeof window === 'undefined') return;
    const host = document.getElementById('globe-3d');
    const status = document.getElementById('globe-status');
    const metaScale = document.getElementById('globe-scale');
    if (!host || !status) return;

    const renderCanvas = () => {
      const canvas = document.createElement('canvas');
      host.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      const omega = 7.2921159e-5; // rad/s
      const speedScale = 2000; // animation multiplier for visibility
      const yScale = 0.82; // squash factor to give an oblique view
      metaScale.textContent = `Animation ×${speedScale} (vs real rotation)`;

      const resize = () => {
        canvas.width = host.clientWidth || 360;
        canvas.height = host.clientHeight || 360;
      };
      window.addEventListener('resize', resize);
      resize();

      let angle = 0;
      let last = performance.now();

      const draw = (ts) => {
        const dt = (ts - last) / 1000;
        last = ts;
        angle += omega * speedScale * dt;

        const { width: w, height: h } = canvas;
        const r = Math.min(w, h) * 0.38;
        const cx = w * 0.5;
        const cy = h * 0.5;

        ctx.clearRect(0, 0, w, h);

        // Sphere (oblique projection)
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(1, yScale);
        const grd = ctx.createRadialGradient(-r * 0.3, -r * 0.35, r * 0.2, 0, 0, r);
        grd.addColorStop(0, '#2c6ead');
        grd.addColorStop(1, '#0b1723');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Prime meridian (Greenwich)
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(1, yScale);
        ctx.rotate(angle);
        ctx.strokeStyle = '#f5a524';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -r);
        ctx.lineTo(0, r);
        ctx.stroke();

        // Polar axis (north–south)
        ctx.strokeStyle = '#9ea7b3';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(-r * 0.02, -r);
        ctx.lineTo(-r * 0.02, r);
        ctx.stroke();
        ctx.restore();

        requestAnimationFrame(draw);
      };

      status.textContent = 'Canvas render';
      status.style.color = 'var(--text-muted)';
      requestAnimationFrame(draw);
    };

    try {
      // Load Three.js and OrbitControls from esm.sh (handles dependencies properly)
      const THREE = await import('https://esm.sh/three@0.161.0')
        .then(mod => mod.default || mod);
      
      const { OrbitControls } = await import('https://esm.sh/three@0.161.0/examples/jsm/controls/OrbitControls.js');

      const scene = new THREE.Scene();
      
      // Star field background
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 1500;
      const starPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const radius = 15 + Math.random() * 10;
        starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i * 3 + 2] = radius * Math.cos(phi);
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.08,
        transparent: true,
        opacity: 0.8
      });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      
      const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
      camera.position.set(2.2, 2.5, 2.8);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      host.appendChild(renderer.domElement);

      // Add OrbitControls for interactive rotation
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // smooth movement
      controls.dampingFactor = 0.05;
      controls.enableZoom = true;
      controls.enablePan = false; // disable panning
      controls.minDistance = 1.5;
      controls.maxDistance = 5;
      controls.autoRotate = false;

      // Earth sphere - WIREFRAME
      const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
      const sphereMat = new THREE.MeshBasicMaterial({
        color: 0x2c6ead,
        wireframe: true,
        wireframeLinewidth: 1.5
      });
      const earth = new THREE.Mesh(sphereGeo, sphereMat);
      scene.add(earth);

      // Greenwich meridian - curve on sphere surface (longitude = 0°)
      const meridianPoints = [];
      const meridianSegments = 64;
      const sphereRadius = 1.01; // slightly larger than sphere for visibility
      for (let i = 0; i <= meridianSegments; i++) {
        const lat = (i / meridianSegments) * Math.PI - Math.PI / 2; // -90° to +90°
        const x = sphereRadius * Math.cos(lat) * Math.cos(0); // longitude = 0
        const y = sphereRadius * Math.sin(lat);
        const z = sphereRadius * Math.cos(lat) * Math.sin(0);
        meridianPoints.push(new THREE.Vector3(x, y, z));
      }
      const meridianGeometry = new THREE.BufferGeometry().setFromPoints(meridianPoints);
      const meridianMaterial = new THREE.LineBasicMaterial({ 
        color: 0xf5a524,
        linewidth: 1
      });
      const meridian = new THREE.Line(meridianGeometry, meridianMaterial);
      earth.add(meridian); // child of earth, so rotates with it

      // Equator line for reference
      const equatorPoints = [];
      const equatorSegments = 64;
      for (let i = 0; i <= equatorSegments; i++) {
        const angle = (i / equatorSegments) * Math.PI * 2;
        const x = sphereRadius * Math.cos(angle);
        const y = 0;
        const z = sphereRadius * Math.sin(angle);
        equatorPoints.push(new THREE.Vector3(x, y, z));
      }
      const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
      const equatorMaterial = new THREE.LineBasicMaterial({ 
        color: 0xf5a524,
        linewidth: 1,
        opacity: 0.4,
        transparent: true
      });
      const equator = new THREE.Line(equatorGeometry, equatorMaterial);
      earth.add(equator);

      // Latitude/longitude grid lines (every 30°)
      const gridMaterial = new THREE.LineBasicMaterial({
        color: 0x556677,
        transparent: true,
        opacity: 0.15
      });
      
      // Latitude lines (parallels)
      for (let lat = -60; lat <= 60; lat += 30) {
        if (lat === 0) continue; // Skip equator (already drawn)
        const latPoints = [];
        const latRad = (lat * Math.PI) / 180;
        const latRadius = sphereRadius * Math.cos(latRad);
        const y = sphereRadius * Math.sin(latRad);
        for (let i = 0; i <= 64; i++) {
          const angle = (i / 64) * Math.PI * 2;
          latPoints.push(new THREE.Vector3(
            latRadius * Math.cos(angle),
            y,
            latRadius * Math.sin(angle)
          ));
        }
        const latGeometry = new THREE.BufferGeometry().setFromPoints(latPoints);
        const latLine = new THREE.Line(latGeometry, gridMaterial);
        earth.add(latLine);
      }
      
      // Longitude lines (meridians)
      for (let lon = 30; lon < 180; lon += 30) {
        const lonPoints = [];
        const lonRad = (lon * Math.PI) / 180;
        for (let i = 0; i <= 64; i++) {
          const lat = (i / 64) * Math.PI - Math.PI / 2;
          lonPoints.push(new THREE.Vector3(
            sphereRadius * Math.cos(lat) * Math.cos(lonRad),
            sphereRadius * Math.sin(lat),
            sphereRadius * Math.cos(lat) * Math.sin(lonRad)
          ));
        }
        const lonGeometry = new THREE.BufferGeometry().setFromPoints(lonPoints);
        const lonLine = new THREE.Line(lonGeometry, gridMaterial);
        earth.add(lonLine);
        
        // Also add the negative longitude
        const lonNegPoints = [];
        const lonNegRad = (-lon * Math.PI) / 180;
        for (let i = 0; i <= 64; i++) {
          const lat = (i / 64) * Math.PI - Math.PI / 2;
          lonNegPoints.push(new THREE.Vector3(
            sphereRadius * Math.cos(lat) * Math.cos(lonNegRad),
            sphereRadius * Math.sin(lat),
            sphereRadius * Math.cos(lat) * Math.sin(lonNegRad)
          ));
        }
        const lonNegGeometry = new THREE.BufferGeometry().setFromPoints(lonNegPoints);
        const lonNegLine = new THREE.Line(lonNegGeometry, gridMaterial);
        earth.add(lonNegLine);
      }

      // Rotation axis - DASHED LINE (DOES NOT rotate - stays fixed in space)
      const axisPoints = [];
      axisPoints.push(new THREE.Vector3(0, -1.5, 0));
      axisPoints.push(new THREE.Vector3(0, 1.5, 0));
      const axisGeometry = new THREE.BufferGeometry().setFromPoints(axisPoints);
      const axisMaterial = new THREE.LineDashedMaterial({
        color: 0x9ea7b3,
        linewidth: 2,
        dashSize: 0.1,
        gapSize: 0.05
      });
      const axis = new THREE.Line(axisGeometry, axisMaterial);
      axis.computeLineDistances();
      scene.add(axis); // NOT a child of earth, so stays fixed

      // Label markers - N and S at axis ends (high-res for crisp text)
      const createTextSprite = (text, color, size = 1, bold = false) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // High resolution for crisp rendering
        const scale = 4; // 4x resolution
        canvas.width = 256 * scale;
        canvas.height = 128 * scale;
        ctx.scale(scale, scale);
        
        // No background - just text with slight glow for visibility
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
        
        ctx.fillStyle = color;
        ctx.font = `${bold ? '700' : '500'} 64px -apple-system, system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Anti-aliasing for smoother text
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        ctx.fillText(text, 128, 64);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        
        const material = new THREE.SpriteMaterial({ 
          map: texture,
          opacity: 0.9,
          transparent: true
        });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(size, size * 0.5, 1);
        return sprite;
      };

      const northLabel = createTextSprite('N', '#cccccc', 0.5, false);
      northLabel.position.set(0, 1.65, 0);
      scene.add(northLabel);

      const southLabel = createTextSprite('S', '#cccccc', 0.5, false);
      southLabel.position.set(0, -1.65, 0);
      scene.add(southLabel);

      // Sun indicator (shows solar angle direction) - DOES NOT rotate
      const sunDistance = 3.5;
      const sunGeometry = new THREE.SphereGeometry(0.15, 16, 16);
      const sunMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffcc00
      });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      
      // Add sun glow
      const sunGlowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
      const sunGlowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffcc00,
        transparent: true,
        opacity: 0.3
      });
      const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
      sun.add(sunGlow);
      
      // Sun ray to Earth (shows solar angle connection)
      const sunRayPoints = [];
      sunRayPoints.push(new THREE.Vector3(0, 0, 0));
      sunRayPoints.push(new THREE.Vector3(sunDistance, 0, 0));
      const sunRayGeometry = new THREE.BufferGeometry().setFromPoints(sunRayPoints);
      const sunRayMaterial = new THREE.LineBasicMaterial({
        color: 0xffcc00,
        transparent: true,
        opacity: 0.4
      });
      const sunRay = new THREE.Line(sunRayGeometry, sunRayMaterial);
      scene.add(sunRay);
      
      sun.position.set(sunDistance, 0, 0);
      scene.add(sun);
      
      // Function to update sun position based on solar angle
      window.updateSunPosition = (solarAngleDeg) => {
        const angleRad = solarAngleDeg * Math.PI / 180;
        sun.position.x = sunDistance * Math.cos(angleRad);
        sun.position.z = sunDistance * Math.sin(angleRad);
        
        // Update sun ray
        sunRayPoints[1].set(sun.position.x, 0, sun.position.z);
        sunRay.geometry.setFromPoints(sunRayPoints);
      };

      // Major cities as reference points (rotates with Earth)
      const cities = [
        { name: 'London', lat: 51.5, lon: 0, color: 0xff4444 },
        { name: 'New York', lat: 40.7, lon: -74, color: 0x44ff44 },
        { name: 'Tokyo', lat: 35.7, lon: 139.7, color: 0x4444ff },
        { name: 'Sydney', lat: -33.9, lon: 151.2, color: 0xffff44 },
        { name: 'Cairo', lat: 30.0, lon: 31.2, color: 0xff44ff },
        { name: 'Muscat', lat: 23.6, lon: 58.4, color: 0x44ffff }
      ];

      const latLonToVector3 = (lat, lon, radius) => {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const z = (radius * Math.sin(phi) * Math.sin(theta));
        const y = (radius * Math.cos(phi));
        return new THREE.Vector3(x, y, z);
      };

      cities.forEach(city => {
        const pos = latLonToVector3(city.lat, city.lon, 1.02);
        
        // City marker (sphere) - smaller
        const cityGeo = new THREE.SphereGeometry(0.02, 8, 8);
        const cityMat = new THREE.MeshBasicMaterial({ 
          color: city.color,
          opacity: 0.8,
          transparent: true
        });
        const cityMarker = new THREE.Mesh(cityGeo, cityMat);
        cityMarker.position.copy(pos);
        earth.add(cityMarker);
        
        // City label - even smaller and closer to prevent clipping
        const cityLabel = createTextSprite(city.name, `#${city.color.toString(16).padStart(6, '0')}`, 0.28);
        const labelPos = latLonToVector3(city.lat, city.lon, 1.08);
        cityLabel.position.copy(labelPos);
        earth.add(cityLabel);
      });

      // Lighting
      const ambient = new THREE.AmbientLight(0x556677, 0.9);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 1.2);
      dir.position.set(3, 2, 2);
      scene.add(dir);

      const resize = () => {
        const w = host.clientWidth || 360;
        const h = host.clientHeight || 360;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      };
      window.addEventListener('resize', resize);
      resize();

      const clock = new THREE.Clock();
      const omega = 7.2921159e-5; // rad/s
      const speedScale = 2000;
      metaScale.textContent = `Animation ×${speedScale} (vs real rotation)`;

      const animate = () => {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const dTheta = omega * speedScale * delta;
        
        // Only Earth rotates (and meridian is its child)
        earth.rotation.y += dTheta;
        
        // Update controls for smooth interaction
        controls.update();
        
        // axis, poles, and labels stay FIXED in space
        
        renderer.render(scene, camera);
      };
      animate();
      status.textContent = 'Interactive (drag to rotate)';
      status.style.color = 'var(--text-muted)';
      
      let isPaused = false;
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (event) => {
        // Space: pause/resume rotation
        if (event.code === 'Space' && event.target.tagName !== 'INPUT') {
          event.preventDefault();
          isPaused = !isPaused;
          status.textContent = isPaused ? 'Paused (Space to resume)' : 'Interactive (drag to rotate)';
        }
        
        // R: reset camera view
        if (event.code === 'KeyR') {
          camera.position.set(2.2, 2.5, 2.8);
          camera.lookAt(0, 0, 0);
          controls.reset();
        }
        
        // F: toggle fullscreen
        if (event.code === 'KeyF') {
          const globeContainer = document.getElementById('globe-3d');
          if (globeContainer) {
            try {
              if (!document.fullscreenElement && 
                  !document.webkitFullscreenElement && 
                  !document.mozFullScreenElement) {
                // Enter fullscreen
                if (globeContainer.requestFullscreen) {
                  globeContainer.requestFullscreen();
                } else if (globeContainer.webkitRequestFullscreen) {
                  globeContainer.webkitRequestFullscreen();
                } else if (globeContainer.mozRequestFullScreen) {
                  globeContainer.mozRequestFullScreen();
                } else if (globeContainer.msRequestFullscreen) {
                  globeContainer.msRequestFullscreen();
                }
              } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                  document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                  document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                  document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                  document.msExitFullscreen();
                }
              }
            } catch (err) {
              console.error('Fullscreen error:', err);
            }
          }
        }
      });
      
      // Update animation loop to respect pause
      const originalAnimate = animate;
      const pausableAnimate = function() {
        requestAnimationFrame(pausableAnimate);
        const delta = clock.getDelta();
        const dTheta = omega * speedScale * delta;
        
        // Only rotate if not paused
        if (!isPaused) {
          earth.rotation.y += dTheta;
        }
        
        controls.update();
        renderer.render(scene, camera);
      };
      
      // Replace the animate function
      requestAnimationFrame(pausableAnimate);
    } catch (err) {
      status.textContent = '3D unavailable (fallback to canvas)';
      status.style.color = '#e1695d';
      console.error('Globe 3D load failed:', err);
      renderCanvas();
    }
  })();

  // UT1 calculator only
  const utcInput = document.getElementById('utc-input');
  const dut1Input = document.getElementById('dut1-input');
  const lonInput = document.getElementById('lon-input');
  const ut1Val = document.getElementById('ut1-val');
  const angleVal = document.getElementById('angle-val');
  const autoUtc = document.getElementById('auto-utc');
  const utcUsed = document.getElementById('utc-used');
  const dut1Applied = document.getElementById('dut1-applied');
  const dut1Reset = document.getElementById('dut1-reset');
  const liveIndicator = document.getElementById('live-indicator');
  const presetButtons = Array.from(document.querySelectorAll('.preset-buttons button'));
  let tick;
  
  // Load saved longitude from localStorage
  const savedLongitude = localStorage.getItem('earth-rotation-longitude');
  if (savedLongitude !== null) {
    lonInput.value = savedLongitude;
  }

  // Set default UTC to current time (rounded to minutes)
  const now = new Date();
  now.setSeconds(0, 0);
  const isoLocal = new Date(now.getTime() - now.getTimezoneOffset() * 60000)
    .toISOString()
    .slice(0, 16);
  utcInput.value = isoLocal;

  function fmtDateWithSeconds(d) {
    const pad = (n) => String(n).padStart(2, '0');
    return `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:${pad(d.getUTCSeconds())} UTC`;
  }

  function compute() {
    let baseMs;
    if (autoUtc.checked) {
      baseMs = Date.now();
      const t = new Date(baseMs - new Date().getTimezoneOffset() * 60000);
      utcInput.value = t.toISOString().slice(0, 16);
    } else {
      baseMs = Date.parse(utcInput.value);
    }
    const utcMs = baseMs;
    if (Number.isNaN(utcMs)) {
      ut1Val.textContent = 'Invalid UTC';
      angleVal.textContent = '—';
      return;
    }
    const dut1 = Number(dut1Input.value) || 0;
    const lon = Number(lonInput.value) || 0;

    // UT1 = UTC + DUT1 (seconds)
    const ut1 = new Date(utcMs + dut1 * 1000);
    utcUsed.textContent = fmtDateWithSeconds(new Date(utcMs));
    dut1Applied.textContent = `${dut1.toFixed(2)} s`;
    ut1Val.textContent = `${fmtDateWithSeconds(ut1)} (UTC + ${dut1.toFixed(2)} s)`;

    // Approximate solar angle at Greenwich (deg) = (UT1 hours * 15) mod 360
    const ut1Hours = (ut1.getUTCHours() + ut1.getUTCMinutes() / 60 + ut1.getUTCSeconds() / 3600);
    const greenwichAngle = (ut1Hours * 15) % 360;
    const localAngle = ((greenwichAngle + lon) % 360 + 360) % 360;
    angleVal.textContent = `${localAngle.toFixed(2)}° (approx local solar angle)`;
    
    // Update sun position in 3D globe if available
    if (window.updateSunPosition) {
      window.updateSunPosition(localAngle);
    }
  }

  utcInput.addEventListener('input', compute);
  dut1Input.addEventListener('input', compute);
  lonInput.addEventListener('input', () => {
    // Save longitude to localStorage
    localStorage.setItem('earth-rotation-longitude', lonInput.value);
    compute();
  });
  autoUtc.addEventListener('change', () => {
    if (autoUtc.checked) {
      if (!tick) tick = setInterval(compute, 1000);
      liveIndicator.style.display = 'inline-flex';
    } else if (tick) {
      clearInterval(tick);
      tick = undefined;
      liveIndicator.style.display = 'none';
    }
    compute();
  });

  presetButtons.forEach((btn) => {
    btn.addEventListener('click', () => {
      const val = Number(btn.dataset.lon);
      lonInput.value = String(val);
      compute();
    });
  });

  dut1Reset.addEventListener('click', () => {
    dut1Input.value = '0.0';
    compute();
  });

  // Fullscreen button handler
  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const globeContainer = document.getElementById('globe-3d');
  
  if (fullscreenBtn && globeContainer) {
    fullscreenBtn.addEventListener('click', async () => {
      try {
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement) {
          // Enter fullscreen
          if (globeContainer.requestFullscreen) {
            await globeContainer.requestFullscreen();
          } else if (globeContainer.webkitRequestFullscreen) {
            await globeContainer.webkitRequestFullscreen();
          } else if (globeContainer.mozRequestFullScreen) {
            await globeContainer.mozRequestFullScreen();
          } else if (globeContainer.msRequestFullscreen) {
            await globeContainer.msRequestFullscreen();
          }
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            await document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            await document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            await document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            await document.msExitFullscreen();
          }
        }
      } catch (err) {
        console.error('Fullscreen error:', err);
        alert('Fullscreen not supported or blocked by browser');
      }
    });
  }
  
  // start ticking
  tick = setInterval(compute, 1000);
  compute();

  // DUT1 Historical Chart
  const dut1Canvas = document.getElementById('dut1-chart');
  if (dut1Canvas) {
    // High-DPI support
    const dpr = window.devicePixelRatio || 1;
    const container = dut1Canvas.parentElement;
    const containerWidth = container ? container.clientWidth - 32 : 700; // minus padding
    const displayW = Math.min(700, containerWidth);
    const displayH = displayW * 0.5; // maintain 2:1 aspect ratio
    dut1Canvas.width = displayW * dpr;
    dut1Canvas.height = displayH * dpr;
    dut1Canvas.style.width = `${displayW}px`;
    dut1Canvas.style.height = `${displayH}px`;
    
    const ctx = dut1Canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    
    const w = displayW;
    const h = displayH;
    const padding = 50;
    const graphW = w - 2 * padding;
    const graphH = h - 2 * padding;
    
    // Sample DUT1 data (approximate values from IERS)
    const data = [
      { year: 2015, dut1: 0.3 },
      { year: 2016, dut1: 0.1 },
      { year: 2017, dut1: -0.2 },
      { year: 2017.5, dut1: 0.9 }, // Leap second added, jumps back up
      { year: 2018, dut1: 0.3 },
      { year: 2019, dut1: 0.0 },
      { year: 2020, dut1: -0.2 },
      { year: 2021, dut1: -0.3 },
      { year: 2022, dut1: -0.5 },
      { year: 2023, dut1: -0.6 },
      { year: 2024, dut1: -0.4 },
      { year: 2025, dut1: -0.2 }
    ];
    
    ctx.fillStyle = '#0c141c';
    ctx.fillRect(0, 0, w, h);
    
    // Draw axes
    ctx.strokeStyle = '#556677';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, h - padding);
    ctx.lineTo(w - padding, h - padding);
    ctx.stroke();
    
    // Draw zero line
    ctx.strokeStyle = '#f5a524';
    ctx.setLineDash([4, 4]);
    const zeroY = padding + graphH / 2;
    ctx.beginPath();
    ctx.moveTo(padding, zeroY);
    ctx.lineTo(w - padding, zeroY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw +0.9s and -0.9s threshold lines
    ctx.strokeStyle = '#e1695d';
    ctx.setLineDash([2, 2]);
    const posThreshY = padding + graphH * (1 - 0.9) / 2;
    const negThreshY = padding + graphH * (1 + 0.9) / 2;
    ctx.beginPath();
    ctx.moveTo(padding, posThreshY);
    ctx.lineTo(w - padding, posThreshY);
    ctx.moveTo(padding, negThreshY);
    ctx.lineTo(w - padding, negThreshY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Labels
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#cccccc';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText('+0.9s', padding - 5, posThreshY);
    ctx.fillText('0s', padding - 5, zeroY);
    ctx.fillText('-0.9s', padding - 5, negThreshY);
    
    // Draw data line
    ctx.strokeStyle = '#2c6ead';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    data.forEach((point, i) => {
      const x = padding + ((point.year - 2015) / (2025 - 2015)) * graphW;
      const y = padding + graphH / 2 - (point.dut1 * graphH / 2);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Draw data points
    ctx.fillStyle = '#5588cc';
    data.forEach(point => {
      const x = padding + ((point.year - 2015) / (2025 - 2015)) * graphW;
      const y = padding + graphH / 2 - (point.dut1 * graphH / 2);
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // X-axis labels
    ctx.fillStyle = '#cccccc';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let year = 2015; year <= 2025; year += 2) {
      const x = padding + ((year - 2015) / (2025 - 2015)) * graphW;
      ctx.fillText(year.toString(), x, h - padding + 5);
    }
    
    // Title
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('DUT1 (UT1 - UTC) Over Time', w / 2, padding - 20);
    
    // Note about leap second
    ctx.font = '11px sans-serif';
    ctx.fillStyle = '#f5a524';
    ctx.textAlign = 'left';
    ctx.fillText('Leap second added →', padding + graphW * 0.25, posThreshY - 10);
  }

  // Leap Seconds Grid
  const leapSecondsGrid = document.getElementById('leap-seconds-grid');
  if (leapSecondsGrid) {
    const leapSeconds = [
      '1972-06-30', '1972-12-31', '1973-12-31', '1974-12-31', '1975-12-31',
      '1976-12-31', '1977-12-31', '1978-12-31', '1979-12-31', '1981-06-30',
      '1982-06-30', '1983-06-30', '1985-06-30', '1987-12-31', '1989-12-31',
      '1990-12-31', '1992-06-30', '1993-06-30', '1994-06-30', '1995-12-31',
      '1997-06-30', '1998-12-31', '2005-12-31', '2008-12-31', '2012-06-30',
      '2015-06-30', '2016-12-31'
    ];
    
    leapSeconds.forEach(date => {
      const item = document.createElement('div');
      item.className = 'leap-second-item';
      item.textContent = date;
      leapSecondsGrid.appendChild(item);
    });
  }
</script>

<style>
  .intro {
    color: var(--text-secondary);
    margin-bottom: 1rem;
  }
  .calc {
    margin-top: 2rem;
  }
  .calc-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1rem;
    margin: 1rem 0 1.5rem;
  }
  label {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    color: var(--text-secondary);
    font-weight: 600;
  }
  .inline {
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
    margin: 0.5rem 0 0;
  }
  .small-note {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-top: 0.2rem;
  }
  .pill {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    color: var(--text-primary);
    padding: 0.25rem 0.55rem;
    border-radius: 999px;
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: 0.85rem;
  }
  .pill:hover {
    border-color: var(--accent-primary);
    color: var(--accent-primary);
  }
  input[type="number"],
  input[type="datetime-local"] {
    padding: 0.55rem 0.65rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    color: var(--text-primary);
    border-radius: 4px;
    font-family: var(--font-mono);
  }
  .links {
    margin: 0.6rem 0 0.4rem;
    font-size: 0.9rem;
  }
  .links a {
    color: var(--accent-secondary);
  }
  .results {
    display: grid;
    gap: 0.35rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    padding: 1rem;
  }
  .results strong {
    color: var(--accent-primary);
  }
  .note {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin-top: 0.75rem;
  }
  .preset-row {
    display: flex;
    align-items: center;
    gap: 0.65rem;
    margin: 0.6rem 0;
    flex-wrap: wrap;
  }
  .preset-buttons {
    display: flex;
    gap: 0.35rem;
    flex-wrap: wrap;
  }
  .live-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.2rem 0.5rem;
    font-size: 0.75rem;
    letter-spacing: 0.8px;
    color: var(--accent-primary);
    border: 1px solid var(--accent-primary);
    border-radius: 999px;
    background: rgba(245,165,36,0.08);
  }
  .viewer {
    margin: 1.5rem 0 1rem;
  }
  .globe-3d {
    position: relative;
    width: min(650px, 100%);
    height: 468px;
    border: 1px solid var(--border-strong);
    background: radial-gradient(circle at 30% 30%, rgba(98,199,255,0.1), transparent 40%), #0c141c;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.05), 0 8px 24px rgba(0,0,0,0.35);
    margin: 0 auto;
    overflow: visible;
  }
  .globe-status {
    position: absolute;
    top: 8px;
    right: 12px;
    font-size: 0.8rem;
    color: var(--text-muted);
    background: rgba(0,0,0,0.5);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    z-index: 10;
  }
  .fullscreen-btn {
    position: absolute;
    top: 8px;
    left: 12px;
    font-size: 1.2rem;
    color: var(--text-primary);
    background: rgba(0,0,0,0.5);
    border: 1px solid var(--border-strong);
    padding: 0.4rem 0.6rem;
    border-radius: 4px;
    cursor: pointer;
    z-index: 10;
    transition: all 0.2s;
  }
  .fullscreen-btn:hover {
    background: rgba(245, 165, 36, 0.3);
    border-color: var(--accent-primary);
    color: var(--accent-primary);
  }
  .keyboard-shortcuts {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    align-items: center;
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    border-radius: 6px;
    font-size: 0.85rem;
  }
  .keyboard-shortcuts strong {
    color: var(--accent-primary);
  }
  .keyboard-shortcuts kbd {
    display: inline-block;
    padding: 0.15rem 0.4rem;
    font-size: 0.75rem;
    font-family: var(--font-mono);
    background: var(--bg-primary);
    border: 1px solid var(--border-strong);
    border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.2);
    margin-right: 0.3rem;
  }
  .globe-info-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }
  .globe-legend {
    display: grid;
    gap: 0.5rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    padding: 0.8rem;
    border-radius: 4px;
  }
  .legend-title {
    font-weight: 700;
    color: var(--accent-primary);
    font-size: 0.85rem;
    margin-bottom: 0.2rem;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
  }
  .legend-color {
    width: 24px;
    height: 12px;
    border-radius: 2px;
    border: 1px solid var(--border-strong);
    flex-shrink: 0;
  }
  .legend-dashed {
    background: repeating-linear-gradient(
      90deg,
      #9ea7b3 0px,
      #9ea7b3 6px,
      transparent 6px,
      transparent 12px
    ) !important;
  }
  .globe-meta {
    display: grid;
    gap: 0.3rem;
    font-size: 0.8rem;
    color: var(--text-secondary);
    background: var(--bg-tertiary);
    padding: 0.8rem;
    border: 1px solid var(--border-strong);
    border-radius: 4px;
  }
  .meta-title {
    font-weight: 700;
    color: var(--accent-primary);
    font-size: 0.85rem;
    margin-bottom: 0.2rem;
  }
  .globe-meta strong {
    color: var(--accent-primary);
    font-weight: 700;
  }
  @media (max-width: 600px) {
    .calc-grid {
      grid-template-columns: 1fr;
    }
    .globe-info-row {
      grid-template-columns: 1fr;
    }
  }

  /* Timeline styles */
  .timeline {
    display: grid;
    gap: 1.5rem;
    margin: 1.5rem 0;
  }
  .timeline-item {
    display: grid;
    grid-template-columns: 100px 1fr;
    gap: 1.5rem;
    padding: 1rem;
    background: var(--bg-tertiary);
    border-left: 3px solid var(--accent-primary);
    border-radius: 4px;
  }
  .timeline-year {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-primary);
    text-align: center;
  }
  .timeline-content h3 {
    margin: 0 0 0.5rem;
    color: var(--text-primary);
    font-size: 1.1rem;
  }
  .timeline-content p {
    margin: 0;
    color: var(--text-secondary);
    font-size: 0.95rem;
  }

  /* Comparison grid */
  .comparison-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin: 1.5rem 0;
  }
  .comparison-card {
    padding: 1.5rem;
    background: var(--bg-tertiary);
    border: 2px solid var(--border-strong);
    border-radius: 8px;
    text-align: center;
  }
  .comparison-card h3 {
    margin: 0 0 0.75rem;
    color: var(--accent-primary);
    font-size: 1.2rem;
  }
  .comparison-value {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary);
    font-family: var(--font-mono);
    margin-bottom: 0.25rem;
  }
  .comparison-exact {
    font-size: 0.9rem;
    color: var(--text-muted);
    font-family: var(--font-mono);
    margin-bottom: 1rem;
  }
  .comparison-card p {
    margin: 0;
    color: var(--text-secondary);
    font-size: 0.95rem;
  }

  /* Chart container */
  .chart-container {
    display: flex;
    justify-content: center;
    margin: 1.5rem 0;
    padding: 1rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    border-radius: 4px;
    overflow-x: auto;
  }
  .chart-container canvas {
    display: block;
    width: 100%;
    max-width: 700px;
    height: auto;
  }

  /* Leap seconds grid */
  .leap-seconds-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 0.75rem;
    margin: 1.5rem 0;
  }
  .leap-second-item {
    padding: 0.6rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    border-radius: 4px;
    text-align: center;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    color: var(--text-primary);
    transition: all 0.2s;
  }
  .leap-second-item:hover {
    border-color: var(--accent-primary);
    background: rgba(245, 165, 36, 0.1);
  }

  /* Variation grid */
  .variation-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    margin: 1.5rem 0;
  }
  .variation-card {
    padding: 1.25rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-strong);
    border-radius: 6px;
  }
  .variation-card h3 {
    margin: 0 0 0.5rem;
    color: var(--accent-primary);
    font-size: 1.1rem;
  }
  .variation-card p {
    margin: 0.4rem 0;
    color: var(--text-secondary);
    font-size: 0.9rem;
  }
  .variation-card strong {
    color: var(--text-primary);
    font-weight: 600;
  }

  @media (max-width: 768px) {
    .timeline-item {
      grid-template-columns: 80px 1fr;
      gap: 1rem;
    }
    .timeline-year {
      font-size: 1.2rem;
    }
    .comparison-grid {
      grid-template-columns: 1fr;
    }
    .variation-grid {
      grid-template-columns: 1fr;
    }
    .leap-seconds-grid {
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    }
  }
</style>

